# 運算式與運算子

運算式是一種特殊的陳述式，他會算出一個值

- 非運算陳述式：指令
- 運算陳述式：要求某樣東西

```
let x;     // 宣告陳述式
x = 3 * 5; // 兩個運算式結合：乘法運算式、賦值運算式
```

非運算子運算式是：

- 識別碼運算式(變數與常數名稱)
- 常值運算式

產生一個值的任何東西都是運算式，那麼變數、常數與常值都是運算式就很合理了。

## 運算子

### 算術運算子

- `+`
- `-`
- `/`
- `*`
- `%`
- `-`：一元負數
- `+`：一元加法
- `++`
- `--`

```
const x = 5;
const y = 3 - -x; // y是8
```

```
const s = "5";
const y = 3 + +s; // y是8
```

### 運算子優先順序

擁有相同優先順序的運算子會從右到左計算，或從左到右計算。例如：乘法與除法有相同優先順序，從左到右計算，而賦值運算子是從右到左計算。

```
let x = 3, y;
x += y = 6*5/2;

// x += y = 15
// 3 += 15
// 18
```

### 比較運算子

- 嚴格相等(`===`、`!==`)

    同一物件，或相同型態與相同的值(原始型態)，就會視為嚴格相等。

- 抽象(寬鬆)相等(`==`、`!=`)

    兩個值是同一物件，**或者可被強制轉換成具相同值**，就會被視為抽象相等。
    
    第二個部分是造成很多麻煩與困擾的地方。建議先將字串轉成數字，再用嚴格相等運算子來比較它們。

- 關係(`>`、`>=`、`<`、`<=`)

    只適合具有自然順序的資料型態(a, b, 0, 1...)
    
### 比較數字

特殊數值`NaN`不等於任何東西，包括自己。想測試某個數字是不是`NaN`，可使用內建的`isNaN`函式。

JavaScript所有數字都是doubles；因為doubles是近似值，所以比較它們時，可能會產生討厭的意外。

比較整數，可放心比較。小數，最好不要使用關係運算子來查看測試數字使否足夠接近目標數字。

JavaScript有一個特殊的數字常數：`Number.EPSILON`，他是很小的值(大約2.22e-16)，通常代表兩個數字被視為不同的差距。

```
let n = 0;
while(true){
  n += 0.1;
  if (n === 0.3) break;
}
console.log(`Stopped at ${n}`);
```

第三次迴圈，n的值是`0.30000000000000004`，所以會永遠執行下去

可使用`Number.EPSILON`與關係運算子來改寫這迴圈，做更“軟性”地比較，以成功停止迴圈。

```
let n = 0;
while(true) {
  n += 0.1;
  if (Math.abs(n - 0.3) < Number.EPSILON) break;
}
console.log(`Stopped at ${n}`); // Stopped at 0.30000000000000004
```

上述這種關係運算子比較方式，經常被用來確定兩個doubles是否夠接近，可被視為相等。

### 字串串接

`+`，可做加法與字串串接。JavaScript會根據運算元的型態，來決定要採取加法還是字串串接。

左到右。

```
3+5+"8" // 8 + "8" = "88"
"3"+5+8 // "35" + 8 = "358"
```

### 邏輯運算子

算術運算子可計算無窮數量的值。邏輯運算子只關心布林值。

但JavaScript可以處理非布林值，它甚至可以回傳非布林值。

#### Truthy與Falsy值

JavaScript包含所有資料型態，可讓你有效的將任何值分成truthy與falsy。

JavaScript將下列的值視為falsy：

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- `''`

很多東西都屬truthy，這裡指出該特別注意的：

- 所有物件(包括使用valueOf()方法時，會回傳false的物件)
- 所有陣列(甚至包括空陣列)
- 裡面只有空白的字串(" ")
- 字串"false"

### AND、OR與NOT

短路計算的範例：

```
const skipIt = true;
let x = 0;
const result = skipIt || x++; // x結果還是0，因為短路計算的關係
```

```
const skipIt = false;
let x = 0;
const result = skipIt && x++; // x結果還是0，因為短路計算的關係
```

```
const skipIt = true;
let x = 0;
const result = skipIt && x++; // result：0
```

#### 計算非布林運算元的邏輯運算子

當使用布林運算元，邏輯運算子永遠會回傳布林值。然而，如果運算元不是布林，將會回傳**決定結果**的值。

```
const options = suppliedOptions || { name: "Default" }; //  suppliedOptions是null或undefined，給預設值
```

NOT邏輯運算子，回傳一定是布林。

#### 條件運算子

JavaScript唯一的**三元**運算子，代表有三個運算元。為`if...else`陳述式的等效運算式。

```
const doIt = false;
const result = doIt ? "Did it!" : "Didn't do it";
```

是運算式，非陳述式，所以有一種很實用的特性，可與其他運算式結合(例如將結果指派給其他變數)。

#### 逗號運算子

提供一種簡單的方式來結合運算式：他只會計算兩個運算式，並回傳第二個結果。當想要執行多個運算式，但只關心最後一個運算式結果，這很方便去使用。

```
let x = 0, y = 10, z;
z = (x++, y++);       // z = 10
```

會經常看到`for`迴圈用它來結合運算式，或函式回傳值之前，用它來結合多個運算式。

### 分組運算子

可修改或明確地標示運算子優先順序。(`(`、`)`)

#### 位元運算子

可對數字中的各個位元執行運算。位元運算子會將它們的運算元當成32位元帶符號整數，採取二的補數格式。JavaScript會在執行位元運算之前，先將數字轉32位元整數，接著在回傳結果之前，將它轉回double。

位元運算子與邏輯運算子有關，因為它們會執行邏輯運算(AND、OR、NOT、XOR)，但他們會對整數的各個位元執行。

位元運算子也包括**位移**運算子，可將位元移到不同位置。

| 運算子 | 說明     | 範例                                                      |
|--------|----------|-----------------------------------------------------------|
| `&`    | 位元AND  | 0b1010 & 0b1100 // 結果：0b1000                           |
| `|`    | 位元OR   | 0b1010 | 0b1100 // 結果：0b1110                           |
| `^`    | 位元XOR  | 0b1010 ^ 0b1100 // 結果：0b0110                           |
| `~`    | 位元NOT  | ~0b1010 // 結果：0b0101                                   |
| `<<`   | 左移     | 0b1010 << 1 // 結果：0b10100；0b1010 << 2 // 結果0b101000 |
| `>>`   | 有極右移 |                                                           |
| `>>>`  | 補零右移 |                                                           |

除非做硬體介面，或想要進一步掌握電腦如何表示數字，否則幾乎用不到位元運算子。

可能會看到一些與硬體無關的用法：使用位元來有效率儲存“旗標”(布林值)。

例如，考慮Unix風格的檔案使用權限：讀、寫與執行。一個使用者可能會被允許這三種設定的任何一種組合。

```
const FLAG_READ 1;    // 0b001
const FLAG_WRITE 2;   // 0b010
const FLAG_EXECUTE 4; // 0b100
```

使用位元運算子，可以結合、切換與偵測一個數值中的各旗標。

```
let p = FLAG_READ | FLAG_WRITE;    // 0b011
let hasWrite = p & FLAG_WRITE;     // 0b010 - truthy
let hasExecute = p & FLAG_EXECUTE; // 0b000 - falsy
p = p ^ FLAG_WRITE;                // 0b001 -- 切換寫入旗標(現在off)
p = p ^ FLAG_WRITE;                // 0b011 -- 切換寫入旗標(現在on)

// 可用一個運算式確定多個旗標
const hasReadAndExecute = p & (FLAG_READ | FLAG_EXECUTE);
```

#### typeof運算子

`typeof`會回傳一個說明運算元的型態字串。不幸的是，他無法完全對應JavaScript的七種資料型態(undefined、null、布林、數字、字串、符號與物件)。

bug： typeof null會回傳object，null當然不是物件，它是基本型態。

typeof無法分辨陣列與非陣列物件。它可正確識別函式

bug2: typeof []結果是"object"

| 運算式               | 回傳值      | 說明     |
|----------------------|-------------|----------|
| typeof undefined     | "undefined" |          |
| typeof null          | "object"    | 令人遺憾 |
| typeof {}            | "object"    |          |
| typeof true          | "boolean"   |          |
| typeof 1             | "number"    |          |
| typeof ""            | "string"    |          |
| typeof Symbol()      | "symbol"    | ES6新增  |
| typeof function() {} | "function"  |          |

#### void運算子

只有一個工作：計算他的運算元，再回傳undefined。可用來強致執行運算式求值，且回傳undefined。

偶爾會在HTML <a>標籤的URI看到它，目的是避免瀏覽器前往新的網頁。

```
<a href="javascript:void 0">Do nothing.</a>
```

不建議這麼做，但會不斷看到它。

#### 賦值運算子

將一個值指派給一個變數。

等號左邊必須是 變數、特性，或陣列元素。必須是某種可以保存值的東西(將一個值指派給一個常數技術上是一種宣告，非賦值操作)。

可以將賦值式串接起來，以及在其他運算式中執行賦值。

```
let v, v0;
v = v0 = 9.8;

const nums = [3, 5, 15, 7, 5];
let n, i = 0;
while((n = nums[i]) < 10 && i++ < nums.length) { // 要用分組運算子，因賦值的優先順序比關係運算子低
  console.log(`Number less than 10: ${n}.`);
}
console.log(`Number greater than 10 found: ${n}.`);
console.log(`${nums.length} numbers remain.`);
```

除一般運算子，還有方便的賦值運算子可在同一步驟執行願算與賦值。

```
x+=y
x-=y
...
```